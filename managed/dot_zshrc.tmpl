DOTFILES_DIR={{ .chezmoi.workingTree }}

if [[ -n $DOTFILES_DIR ]]; then
  export PROJECTS={{ .projectDir }}

  # Add the functions directory to the fpath
  fpath=($DOTFILES_DIR/functions $fpath)
  # Load all the functions
  autoload -U $DOTFILES_DIR/functions/*(:t)

  # Per-project history - up arrow prioritizes commands from current project
  # https://github.com/ivan-cukic/zsh-per-project-history
  if [[ -f "$DOTFILES_DIR/plugins/per-project-history.plugin.zsh" ]]; then
    source "$DOTFILES_DIR/plugins/per-project-history.plugin.zsh"
  fi
fi

# Initialize completion system
autoload -U compinit
compinit

# Case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
# Menu-style completion
zstyle ':completion:*' menu select

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# History deduplication settings
setopt HIST_IGNORE_ALL_DUPS   # Delete old entry if new entry is duplicate
setopt HIST_EXPIRE_DUPS_FIRST # Remove duplicates first when trimming history
setopt HIST_IGNORE_SPACE      # Ignore commands that start with space

export HISTFILE=~/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000

# History sharing and real-time updates
setopt SHARE_HISTORY          # Share history between all sessions
setopt INC_APPEND_HISTORY     # Write to history file immediately after each command

# setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries in history file

# Edit command line in editor
autoload -U edit-command-line
zle -N edit-command-line

# Key bindings

bindkey -e

bindkey '^X^E' edit-command-line

autoload -U up-line-or-beginning-search
zle -N up-line-or-beginning-search
bindkey -M emacs "^[[A" up-line-or-beginning-search
bindkey -M viins "^[[A" up-line-or-beginning-search
bindkey -M vicmd "^[[A" up-line-or-beginning-search

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

export EDITOR='nvim'
export ERL_AFLAGS="-kernel shell_history enabled"

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

export ASDF_DATA_DIR="$HOME/.asdf"
export PATH="$ASDF_DATA_DIR/shims:$PATH"

[[ -d "/opt/homebrew/share/google-cloud-sdk/bin" ]] && export PATH="$PATH:/opt/homebrew/share/google-cloud-sdk/bin"
export PATH="$PATH:$HOME/.antigravity/antigravity/bin"

export PATH="$HOME/.bun/bin:$PATH"
export PATH="./.bin:$HOME/.bin:$HOME/.local/bin:$PATH"

# Aliases

alias ls='ls --color=auto'
alias e='$EDITOR'

export ENABLE_LSP_TOOL=1
# alias claude="/Users/stuart/.claude/local/claude"

export FZF_ALT_C_OPTS="
  --walker-skip .git,node_modules,target,.elixir_ls,_build"

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

source <(fzf --zsh)

# if [[ $- == *i* ]]; then
#   # Disable focus reporting for interactive shells only
#   # Fixes occasional issue when Claude Code starts print [I [O when switching focus.
#   printf '\e[?1004l' 2>/dev/null
# fi

if command -v zoxide &> /dev/null; then
  if [[ -n "$CLAUDECODE" ]]; then
    # In Claude Code, don't replace cd to avoid snapshot issues
    eval "$(zoxide init zsh)"
  else
    eval "$(zoxide init zsh --cmd cd)"
  fi
fi

eval "$(starship init zsh)"

# Tmux wrapper functions (auto-enabled for remote environments)
# Override: DOTFILES_TMUX_WRAPPERS=1 (force on) or =0 (force off)
# Configure commands: TMUX_WRAP_COMMANDS=(claude nvim vim)

_tmux_wrappers_enabled() {
  # Explicit override takes precedence
  [[ "$DOTFILES_TMUX_WRAPPERS" == "0" ]] && return 1
  [[ "$DOTFILES_TMUX_WRAPPERS" == "1" ]] && return 0
  # Auto-detect remote environments
  [[ -n "$SSH_CONNECTION" || -n "$REMOTE_CONTAINERS" || -n "$CODESPACES" ]]
}

if _tmux_wrappers_enabled; then
  # Default commands to wrap (can be overridden before this runs)
  (( ${#TMUX_WRAP_COMMANDS[@]} )) || TMUX_WRAP_COMMANDS=(claude nvim)

  _tmux_wrap() {
    local cmd="$1"
    shift

    if [[ -n "$TMUX" ]]; then
      # Already in tmux, just run the command
      command "$cmd" "$@"
    else
      # Not in tmux: create/attach session and run command
      local session_name="$cmd"
      local working_dir="${PROJECTS:-$HOME}"

      if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux attach-session -t "$session_name"
      else
        tmux new-session -s "$session_name" -c "$working_dir" \; send-keys "$cmd $*" Enter
      fi
    fi
  }

  # Generate wrapper functions for each command
  for _cmd in "${TMUX_WRAP_COMMANDS[@]}"; do
    eval "$_cmd() { _tmux_wrap $_cmd \"\$@\"; }"
  done
  unset _cmd
fi
